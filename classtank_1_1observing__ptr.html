<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.7"/>
        <script type="text/javascript" src="jquery-2.1.3.min.js"></script>
        <script>
          $(function(){
            $("td.memSeparator").remove();
          })
        </script>
        <title>Tank: tank::observing_ptr&lt; T &gt; Class Template Reference</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link rel="stylesheet" href="bootstrap3/css/bootstrap.min.css">
        <script src="bootstrap3/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="doxy-boot.js"></script>
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">Tank </a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel panel-default" style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>tank</b></li><li class="navelem"><a class="el" href="classtank_1_1observing__ptr.html">observing_ptr</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classtank_1_1observing__ptr-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tank::observing_ptr&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Dumb pointer class.  
 <a href="classtank_1_1observing__ptr.html#details">More...</a></p>

<p><code>#include &lt;Tank/Utility/observing_ptr.hpp&gt;</code></p>
<div class="dynheader">
Inheritance diagram for tank::observing_ptr&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><!-- SVG 0 -->
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a705b848c6e20c5db995890a73fcc35fa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtank_1_1observing__ptr.html#a705b848c6e20c5db995890a73fcc35fa">observing_ptr</a> ()=default</td></tr>
<tr class="memdesc:a705b848c6e20c5db995890a73fcc35fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a705b848c6e20c5db995890a73fcc35fa">More...</a><br /></td></tr>
<tr class="separator:a705b848c6e20c5db995890a73fcc35fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebafe969291244a6b970c6e69754e81f"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:aebafe969291244a6b970c6e69754e81f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtank_1_1observing__ptr.html#aebafe969291244a6b970c6e69754e81f">observing_ptr</a> (const <a class="el" href="classtank_1_1observing__ptr.html">observing_ptr</a>&lt; U &gt; &amp;ptr)</td></tr>
<tr class="memdesc:aebafe969291244a6b970c6e69754e81f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#aebafe969291244a6b970c6e69754e81f">More...</a><br /></td></tr>
<tr class="separator:aebafe969291244a6b970c6e69754e81f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e52c24781c04bcb60fc2d0672b42101"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtank_1_1observing__ptr.html#a9e52c24781c04bcb60fc2d0672b42101">observing_ptr</a> (std::nullptr_t)</td></tr>
<tr class="memdesc:a9e52c24781c04bcb60fc2d0672b42101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a nullptr.  <a href="#a9e52c24781c04bcb60fc2d0672b42101">More...</a><br /></td></tr>
<tr class="separator:a9e52c24781c04bcb60fc2d0672b42101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0801ce93220e31c46cb49d5fd56fce5"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:ae0801ce93220e31c46cb49d5fd56fce5"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtank_1_1observing__ptr.html#ae0801ce93220e31c46cb49d5fd56fce5">observing_ptr</a> (const std::unique_ptr&lt; U &gt; &amp;ptr)</td></tr>
<tr class="memdesc:ae0801ce93220e31c46cb49d5fd56fce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a unique_ptr.  <a href="#ae0801ce93220e31c46cb49d5fd56fce5">More...</a><br /></td></tr>
<tr class="separator:ae0801ce93220e31c46cb49d5fd56fce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7034052a97abe284bce073d5db720a"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a0b7034052a97abe284bce073d5db720a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtank_1_1observing__ptr.html#a0b7034052a97abe284bce073d5db720a">observing_ptr</a> (U *ptr)</td></tr>
<tr class="memdesc:a0b7034052a97abe284bce073d5db720a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from a raw pointer.  <a href="#a0b7034052a97abe284bce073d5db720a">More...</a><br /></td></tr>
<tr class="separator:a0b7034052a97abe284bce073d5db720a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ac7200eed606a36ca53e50ffcd8c2a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtank_1_1observing__ptr.html#a92ac7200eed606a36ca53e50ffcd8c2a">observing_ptr</a> (T &amp;ref)</td></tr>
<tr class="memdesc:a92ac7200eed606a36ca53e50ffcd8c2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from a reference.  <a href="#a92ac7200eed606a36ca53e50ffcd8c2a">More...</a><br /></td></tr>
<tr class="separator:a92ac7200eed606a36ca53e50ffcd8c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61be232ab9cbac795cc77b01c573e184"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtank_1_1observing__ptr.html#a61be232ab9cbac795cc77b01c573e184">operator*</a> () const </td></tr>
<tr class="memdesc:a61be232ab9cbac795cc77b01c573e184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dereference operator.  <a href="#a61be232ab9cbac795cc77b01c573e184">More...</a><br /></td></tr>
<tr class="separator:a61be232ab9cbac795cc77b01c573e184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398d9b877c6b379074c20bb53f8caf6e"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtank_1_1observing__ptr.html#a398d9b877c6b379074c20bb53f8caf6e">operator-&gt;</a> () const </td></tr>
<tr class="memdesc:a398d9b877c6b379074c20bb53f8caf6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Member access operator.  <a href="#a398d9b877c6b379074c20bb53f8caf6e">More...</a><br /></td></tr>
<tr class="separator:a398d9b877c6b379074c20bb53f8caf6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a7d54421b85143d27172c56eac3760"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtank_1_1observing__ptr.html#ad1a7d54421b85143d27172c56eac3760">operator bool</a> () const </td></tr>
<tr class="memdesc:ad1a7d54421b85143d27172c56eac3760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit bool conversion operator.  <a href="#ad1a7d54421b85143d27172c56eac3760">More...</a><br /></td></tr>
<tr class="separator:ad1a7d54421b85143d27172c56eac3760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51223e75df1e6e95ddc1628730e2c712"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtank_1_1observing__ptr.html#a51223e75df1e6e95ddc1628730e2c712">operator==</a> (const std::unique_ptr&lt; T &gt; &amp;other) const </td></tr>
<tr class="memdesc:a51223e75df1e6e95ddc1628730e2c712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison with unique_ptr.  <a href="#a51223e75df1e6e95ddc1628730e2c712">More...</a><br /></td></tr>
<tr class="separator:a51223e75df1e6e95ddc1628730e2c712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6560ce45eff094b5978221337d5074eb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtank_1_1observing__ptr.html#a6560ce45eff094b5978221337d5074eb">operator!=</a> (const std::unique_ptr&lt; T &gt; &amp;other) const </td></tr>
<tr class="memdesc:a6560ce45eff094b5978221337d5074eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison with unique_ptr.  <a href="#a6560ce45eff094b5978221337d5074eb">More...</a><br /></td></tr>
<tr class="separator:a6560ce45eff094b5978221337d5074eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2907848ce1a73473d24ac0d800e1c738"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtank_1_1observing__ptr.html#a2907848ce1a73473d24ac0d800e1c738">operator==</a> (const T *const other) const </td></tr>
<tr class="memdesc:a2907848ce1a73473d24ac0d800e1c738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison with raw pointer.  <a href="#a2907848ce1a73473d24ac0d800e1c738">More...</a><br /></td></tr>
<tr class="separator:a2907848ce1a73473d24ac0d800e1c738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb98562da4da3a8e78897715ce904ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtank_1_1observing__ptr.html#acdb98562da4da3a8e78897715ce904ae">operator!=</a> (const T *const other) const </td></tr>
<tr class="memdesc:acdb98562da4da3a8e78897715ce904ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison with raw pointer.  <a href="#acdb98562da4da3a8e78897715ce904ae">More...</a><br /></td></tr>
<tr class="separator:acdb98562da4da3a8e78897715ce904ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29b57c5ce38a5dc732e78aa5edc38db2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtank_1_1observing__ptr.html#a29b57c5ce38a5dc732e78aa5edc38db2">operator==</a> (const T &amp;other) const </td></tr>
<tr class="memdesc:a29b57c5ce38a5dc732e78aa5edc38db2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison with reference.  <a href="#a29b57c5ce38a5dc732e78aa5edc38db2">More...</a><br /></td></tr>
<tr class="separator:a29b57c5ce38a5dc732e78aa5edc38db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8acaf463fb04d830a7e57a647ebd5e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtank_1_1observing__ptr.html#a0f8acaf463fb04d830a7e57a647ebd5e">operator!=</a> (const T &amp;other) const </td></tr>
<tr class="memdesc:a0f8acaf463fb04d830a7e57a647ebd5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison with reference.  <a href="#a0f8acaf463fb04d830a7e57a647ebd5e">More...</a><br /></td></tr>
<tr class="separator:a0f8acaf463fb04d830a7e57a647ebd5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3513b299b2734fd1bb11ffecbc52895d"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtank_1_1observing__ptr.html#a3513b299b2734fd1bb11ffecbc52895d">get</a> ()</td></tr>
<tr class="memdesc:a3513b299b2734fd1bb11ffecbc52895d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the contained pointer.  <a href="#a3513b299b2734fd1bb11ffecbc52895d">More...</a><br /></td></tr>
<tr class="separator:a3513b299b2734fd1bb11ffecbc52895d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a231ab0756183dcb5679b856488afe96d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a231ab0756183dcb5679b856488afe96d"></a>
template&lt;typename U  = T&gt; </td></tr>
<tr class="memitem:a231ab0756183dcb5679b856488afe96d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator not_bool_convertible&lt; U &gt; &amp;</b> ()</td></tr>
<tr class="separator:a231ab0756183dcb5679b856488afe96d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a587f43f0e9e12160331abf54e627ca1b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a587f43f0e9e12160331abf54e627ca1b"></a>
template&lt;typename U  = T&gt; </td></tr>
<tr class="memitem:a587f43f0e9e12160331abf54e627ca1b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator const not_bool_convertible&lt; U &gt; &amp;</b> () const </td></tr>
<tr class="separator:a587f43f0e9e12160331abf54e627ca1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aa09ebd84bcf2d257b262c799abdeb0d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa09ebd84bcf2d257b262c799abdeb0d5"></a>
struct&#160;</td><td class="memItemRight" valign="bottom"><b>std::hash&lt; observing_ptr &gt;</b></td></tr>
<tr class="separator:aa09ebd84bcf2d257b262c799abdeb0d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class tank::observing_ptr&lt; T &gt;</h3>

<p>Dumb pointer class. </p>
<p>This class exists to protect memory that is owned by the game engine from being modified by users. Although a raw pointer could be used here, using a dumb pointer class makes it clear that the user is not expected to manage the memory. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a705b848c6e20c5db995890a73fcc35fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtank_1_1observing__ptr.html">tank::observing_ptr</a>&lt; T &gt;::<a class="el" href="classtank_1_1observing__ptr.html">observing_ptr</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Sets the pointer to null. </p>

</div>
</div>
<a class="anchor" id="aebafe969291244a6b970c6e69754e81f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtank_1_1observing__ptr.html">tank::observing_ptr</a>&lt; T &gt;::<a class="el" href="classtank_1_1observing__ptr.html">observing_ptr</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtank_1_1observing__ptr.html">observing_ptr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>This allows copy construction from another <a class="el" href="classtank_1_1observing__ptr.html" title="Dumb pointer class. ">observing_ptr</a>. It takes an <a class="el" href="classtank_1_1observing__ptr.html" title="Dumb pointer class. ">observing_ptr</a> of type U instead of T to allow conversion from a pointer to a derived type to a pointer to a base type. </p>

</div>
</div>
<a class="anchor" id="a9e52c24781c04bcb60fc2d0672b42101"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtank_1_1observing__ptr.html">tank::observing_ptr</a>&lt; T &gt;::<a class="el" href="classtank_1_1observing__ptr.html">observing_ptr</a> </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from a nullptr. </p>
<p>This ensures that when constructing with the new nullptr value in C++11 the inner pointer is constructed properly. </p>

</div>
</div>
<a class="anchor" id="ae0801ce93220e31c46cb49d5fd56fce5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtank_1_1observing__ptr.html">tank::observing_ptr</a>&lt; T &gt;::<a class="el" href="classtank_1_1observing__ptr.html">observing_ptr</a> </td>
          <td>(</td>
          <td class="paramtype">const std::unique_ptr&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from a unique_ptr. </p>
<p>This allows construction from a unique pointer, setting the <a class="el" href="classtank_1_1observing__ptr.html" title="Dumb pointer class. ">observing_ptr</a> to the same address. This does not perform a copy. The reason this does not break unique_ptr's uniqueness contract is that <a class="el" href="classtank_1_1observing__ptr.html" title="Dumb pointer class. ">observing_ptr</a> is not an owning smart pointer and cannot delete its internal pointer.</p>
<p>This takes a unique_ptr of type U to allow conversion from a unique_ptr to a derived type to an <a class="el" href="classtank_1_1observing__ptr.html" title="Dumb pointer class. ">observing_ptr</a> of base type. </p>

</div>
</div>
<a class="anchor" id="a0b7034052a97abe284bce073d5db720a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtank_1_1observing__ptr.html">tank::observing_ptr</a>&lt; T &gt;::<a class="el" href="classtank_1_1observing__ptr.html">observing_ptr</a> </td>
          <td>(</td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from a raw pointer. </p>
<p>This allows construction from a raw pointer, setting the <a class="el" href="classtank_1_1observing__ptr.html" title="Dumb pointer class. ">observing_ptr</a> to the same address. This allows raw pointers to be wrapped in observing_ptrs for safety.</p>
<p>This takes a raw pointer of type U to allow conversion from a raw pointer to a derived type to an <a class="el" href="classtank_1_1observing__ptr.html" title="Dumb pointer class. ">observing_ptr</a> of base type. </p>

</div>
</div>
<a class="anchor" id="a92ac7200eed606a36ca53e50ffcd8c2a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtank_1_1observing__ptr.html">tank::observing_ptr</a>&lt; T &gt;::<a class="el" href="classtank_1_1observing__ptr.html">observing_ptr</a> </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from a reference. </p>
<p>This constructor exists to aid the use of certain STL algorithms.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>This is hacky and doesn't fit well with other constructors for this class. It will probably be removed once uses of it in the engine itself are removed.</dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a3513b299b2734fd1bb11ffecbc52895d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classtank_1_1observing__ptr.html">tank::observing_ptr</a>&lt; T &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the contained pointer. </p>
<p>This doesn't check for null, so it will return a null pointer if the <a class="el" href="classtank_1_1observing__ptr.html" title="Dumb pointer class. ">observing_ptr</a> is null. </p>

</div>
</div>
<a class="anchor" id="ad1a7d54421b85143d27172c56eac3760"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtank_1_1observing__ptr.html">tank::observing_ptr</a>&lt; T &gt;::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Explicit bool conversion operator. </p>
<dl class="section return"><dt>Returns</dt><dd>Whether the pointer is null. </dd></dl>

</div>
</div>
<a class="anchor" id="a6560ce45eff094b5978221337d5074eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtank_1_1observing__ptr.html">tank::observing_ptr</a>&lt; T &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const std::unique_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison with unique_ptr. </p>
<dl class="section note"><dt>Note</dt><dd>This performs a pointer comparison, not an object comparison.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the pointers are not equal. </dd></dl>

</div>
</div>
<a class="anchor" id="acdb98562da4da3a8e78897715ce904ae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtank_1_1observing__ptr.html">tank::observing_ptr</a>&lt; T &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const T *const&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison with raw pointer. </p>
<dl class="section note"><dt>Note</dt><dd>This performs a pointer comparison, not an object comparison.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the pointers are not equal. </dd></dl>

</div>
</div>
<a class="anchor" id="a0f8acaf463fb04d830a7e57a647ebd5e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtank_1_1observing__ptr.html">tank::observing_ptr</a>&lt; T &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison with reference. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>This is quite an odd function to have, and doesn't really match the behaviour of the others. It may be removed once uses of it are removed from the rest of the engine.</dd></dl>

</div>
</div>
<a class="anchor" id="a61be232ab9cbac795cc77b01c573e184"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classtank_1_1observing__ptr.html">tank::observing_ptr</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dereference operator. </p>
<p>This operator behaves exactly as if the pointer was a raw pointer. <b>This means that calling these functions on a null pointer exhibits undefined behavior.</b></p>
<dl class="section return"><dt>Returns</dt><dd>The pointer to value. </dd></dl>

</div>
</div>
<a class="anchor" id="a398d9b877c6b379074c20bb53f8caf6e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classtank_1_1observing__ptr.html">tank::observing_ptr</a>&lt; T &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Member access operator. </p>
<p>This operator behaves exactly as if the pointer was a raw pointer. <b>This means that calling these functions on a null pointer exhibits undefined behavior.</b></p>
<dl class="section return"><dt>Returns</dt><dd>The pointer to value. </dd></dl>

</div>
</div>
<a class="anchor" id="a51223e75df1e6e95ddc1628730e2c712"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtank_1_1observing__ptr.html">tank::observing_ptr</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const std::unique_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison with unique_ptr. </p>
<dl class="section note"><dt>Note</dt><dd>This performs a pointer comparison, not an object comparison.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the pointers are equal. </dd></dl>

</div>
</div>
<a class="anchor" id="a2907848ce1a73473d24ac0d800e1c738"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtank_1_1observing__ptr.html">tank::observing_ptr</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const T *const&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison with raw pointer. </p>
<dl class="section note"><dt>Note</dt><dd>This performs a pointer comparison, not an object comparison.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the pointers are equal. </dd></dl>

</div>
</div>
<a class="anchor" id="a29b57c5ce38a5dc732e78aa5edc38db2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtank_1_1observing__ptr.html">tank::observing_ptr</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison with reference. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>This is quite an odd function to have, and doesn't really match the behaviour of the others. It may be removed once uses of it are removed from the rest of the engine.</dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
</small></address>
</body>
</html>
